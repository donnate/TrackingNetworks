args=list(p=0.1)
param2test=data.frame(order_max=c(5,5,3,3,3,1),alpha=c(0.5,1.2,0.5,0.9,1,1))
dist=test_bootstrap(N,args,opts=0,B=100,param2test = param2test)
names=c()
for (i in 1:nrow(param2test)){
names=cbind(names,paste("O=",param2test$order_max[i],",a=",param2test$alpha[i],sep=''))
}
boxplot(t(dist),names=names,main="Polynomial distances for a Power Law graph (a=1.4) on 100 nodes")
N=100
args=list(islands.n=7,islands.size=15,islands.pin=0.35,n.inter=7)
param2test=data.frame(order_max=c(5,5,3,3,3,1),alpha=c(0.5,1.2,0.5,0.9,1,1))
dist=test_bootstrap(N,args,opts=2,B=100,param2test = param2test)
names=c()
for (i in 1:nrow(param2test)){
names=cbind(names,paste("O=",param2test$order_max[i],",a=",param2test$alpha[i],sep=''))
}
boxplot(t(dist),names=names,main="Polynomial distances for an ER graph (p=0.25) on 100 nodes")
N=100
args=list(block.sizes=c(35,35,35))
param2test=data.frame(order_max=c(5,5,3,3,3,1),alpha=c(0.5,1.2,0.5,0.9,1,1))
dist=test_bootstrap(N,args,opts=4,B=100,param2test = param2test)
N=100
#args=list(block.sizes=c(35,35,35))
param2test=data.frame(order_max=c(5,5,3,3,3,1),alpha=c(0.5,1.2,0.5,0.9,1,1))
dist=test_bootstrap(105,args,opts=4,B=100,param2test = param2test)
A2<-generate_realistic_adjacency(105,args_l=args,opts=4, verbose=TUEE)
A2<-generate_realistic_adjacency(105,args_l=args,opts=4, verbose=TRUE)
?sample_sbm
test_mat=pm=cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5))
View(test_mat)
test_mat=pm=matrix(cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5)))
test_mat=pm=matrix(cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5)),3,3)
print(pm)
A2<-generate_realistic_adjacency(105,args_l=args,opts=4, verbose=TRUE)
## Two groups with not only few connection between groups
pm <- cbind( c(.1, .001), c(.001, .05) )
g <- sample_sbm(1000, pref.matrix=pm, block.sizes=c(300,700))
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/dynamics.R', echo=TRUE)
A2<-generate_realistic_adjacency(105,args_l=args,opts=4, verbose=TRUE)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/dynamics.R', echo=TRUE)
A2<-generate_realistic_adjacency(105,args_l=args,opts=4, verbose=TRUE)
A2<-generate_realistic_adjacency(105,opts=4, verbose=TRUE)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/dynamics.R', echo=TRUE)
N=100
#args=list(block.sizes=c(35,35,35))
param2test=data.frame(order_max=c(5,5,3,3,3,1),alpha=c(0.5,1.2,0.5,0.9,1,1))
dist=test_bootstrap(105,opts=4,B=100,param2test = param2test)
N=100
#args=list(block.sizes=c(35,35,35))
param2test=data.frame(order_max=c(5,5,3,3,3,1),alpha=c(0.5,1.2,0.5,0.9,1,1))
dist=test_bootstrap(105,args=c(),opts=4,B=100,param2test = param2test)
names=c()
for (i in 1:nrow(param2test)){
names=cbind(names,paste("O=",param2test$order_max[i],",a=",param2test$alpha[i],sep=''))
}
boxplot(t(dist),names=names,main="Polynomial distances for an SBM graph (3 even blocks) on 105 nodes")
dist=test_bootstrap_shiny_ST(N,alpha,order_max,args,opts=1,B)
dist=test_bootstrap_shiny_ST(N,alpha,order_max,args,opts=1,2)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
dist=test_bootstrap_shiny_ST(N,alpha,order_max,args,opts=1,2)
dist=test_bootstrap_shiny_ST(N,alpha,order_max,args=c(power=1.4),opts=1,2)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
dist=test_bootstrap_shiny_ST(N,order_max,args=c(power=1.4),opts=1,2)
args=c(power=1.4)
pots=1
opts=1
A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
args=list(power=1.4)
A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
dist=test_bootstrap_shiny_ST(N,order_max,args=list(power=1.4),opts=1,2)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
dist=test_bootstrap_shiny_ST(N,order_max,args=list(power=1.4),opts=1,2)
A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
stree<-get_number_spanning_trees(A)
stree2<-get_number_spanning_trees(A2)
dist=abs(stree-stree2)/(stree+stree2)
ST_distance(A,A2)
ST_distance(A,A2,norm=TRUE)
N=nrow(A)
B_ref<-(-1.0)*as.matrix(A)  ### B_ref is the Laplacian of the graph
diag(B_ref)<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
(length(which(diag(B_ref)==0))>0 )
A<-generate_realistic_adjacency(N,args_l=list(p=0.1),opts=0, verbose=TRUE)
N=nrow(A)
B_ref<-(-1.0)*as.matrix(A)  ### B_ref is the Laplacian of the graph
diag(B_ref)<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
A<-as.matrix(get.adjacency(A))
N=nrow(A)
B_ref<-(-1.0)*as.matrix(A)  ### B_ref is the Laplacian of the graph
diag(B_ref)<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
(length(which(diag(B_ref)==0))>0 )
N=20
A<-generate_realistic_adjacency(N,args_l=list(p=0.1),opts=0, verbose=TRUE)
A<-as.matrix(get.adjacency(A))
N=nrow(A)
B_ref<-(-1.0)*as.matrix(A)  ### B_ref is the Laplacian of the graph
diag(B_ref)<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
(length(which(diag(B_ref)==0))>0 )
index=which(diag(B_ref)==0)
index
index_connected<-setdiff(1:N,index)
index_connected
D=sapply(1:N, FUN=function(i){
return(sum(A[i,]))
})
D=diag(D)
D
D=sapply(1:N, FUN=function(i){
return(sum(A[i,]))
})
D
apply(A,1,sum)
lambda=eigen(D-A,only.values = T)
lambda
ll=lambda$values[which(lambda$values>10^(-7))]
ll
A<-A[index_connected,index_connected]
D<-apply(A,1,sum)
D=diag(D)
lambda=eigen(D-A,only.values = T) ## eigenvalues of the Laplacian
ll=lambda$values[which(lambda$values>10^(-7))]
ll
ll=lambda$values[which(lambda$values>0)]
ll
lambda$values[
lambda$values
length(lambda$values)
length(ll)
ll
nb_blocks=length(lambda$values==0)
nb_blocks
nb_blocks=sum(lambda$values==0)
nb_blocks
length(lambda$values>10^(-13))
sum(lambda$values>10^(-13))
length(lambda$values<10^(-13))
sum(lambda$values<10^(-13))
ll=lambda$values[which(lambda$values>10^(-14))]
nb=-log(N)+sum(log(ll)
)
nb
source("./distances/spanning_trees.R")
get_number_spanning_trees(A,adjust_disconnection=TRUE)
A<-generate_realistic_adjacency(N=20,args_l=list(p=0.1),opts=0, verbose=TRUE)
G=A
A<-as.matrix(get.adjacency(G))
n=get_number_spanning_trees(A,adjust_disconnection=TRUE,verbose=TRUE)
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
n=get_number_spanning_trees(A,adjust_disconnection=TRUE,verbose=TRUE)
N=nrow(A)
#B_ref<-(-1.0)*as.matrix(A)
D<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
N
D
if (length(which(diag(D)==0))>0 ) print(paste("disconnected component(s): ",which(diag(D)==0)))
verbose=TRUE
if (length(which(diag(D)==0))>0 & verbose ) print(paste("disconnected component(s): ",which(D==0)))
D
which(D==0)
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
n=get_number_spanning_trees(A,adjust_disconnection=TRUE,verbose=TRUE)
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
n=get_number_spanning_trees(A,adjust_disconnection=TRUE,verbose=TRUE)
if (length(which(diag(D)==0))>0 && N>2 && adjust_disconnection==TRUE){  ## adjust the disconnection
index=which(diag(D)==0)
index_connected<-setdiff(1:N,index)
A<-A[index_connected,index_connected]
return(get_number_spanning_trees(A,adjust_disconnection=TRUE))
}
adjust_disconnection=TRUE
if (length(which(diag(D)==0))>0 && N>2 && adjust_disconnection==TRUE){  ## adjust the disconnection
index=which(diag(D)==0)
index_connected<-setdiff(1:N,index)
A<-A[index_connected,index_connected]
return(get_number_spanning_trees(A,adjust_disconnection=TRUE))
}
if (length(which(D==0))>0 && N>2 && adjust_disconnection==TRUE){  ## adjust the disconnection
index=which(D==0)
index_connected<-setdiff(1:N,index)
A<-A[index_connected,index_connected]
return(get_number_spanning_trees(A,adjust_disconnection=TRUE))
}
(length(which(D==0))>0 && N>2 && adjust_disconnection==TRUE)
index=which(D==0)
index
index_connected<-setdiff(1:N,index)
A<-A[index_connected,index_connected]
index_connected
ncol(A)
A<-as.matrix(get.adjacency(AG)
A<-as.matrix(get.adjacency(G))
A<-A[index_connected,index_connected]
A
get_number_spanning_trees(A,adjust_disconnection=TRUE)
A
N=nrow(A)
#B_ref<-(-1.0)*as.matrix(A)
D<-apply(A,1,sum)
D
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
get_number_spanning_trees(as.matrix(get.adjacency(G)),adjust_disconnection=TRUE)
A=as.matrix(get.adjacency(A))
A=as.matrix(get.adjacency(G))
N=nrow(A)
#B_ref<-(-1.0)*as.matrix(A)
D<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
if (length(D==0)>0 & verbose ) print(paste("isolated node(s): ",which(D==0)))
#### Th
index=which(D==0)
index_connected<-setdiff(1:N,index)
A<-A[index_connected,index_connected]
A
D<-apply(A,1,sum)
D=diag(D)
lambda=eigen(D-A,only.values = T) ## eigenvalues of the Laplacian
## check the number of disconnect blocks
nb_blocks=length(lambda$values<10^(-14)) ###numerical error
nb_blocks
lambda=
lambda
nb_blocks=sum(lambda$values<10^(-14))
nb_blocks
graph=graph_from_adjacency_matrix(A, mode = "undirected")
index_cliques=igraph::components(graph)
selection=which(index_cliques$membership==1)
selection
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
get_number_spanning_trees(as.matrix(get.adjacency(G)),adjust_disconnection=TRUE)
get_number_spanning_trees(as.matrix(get.adjacency(G)),adjust_disconnection=TRUE,verbose=FALSE)
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
get_number_spanning_trees(as.matrix(get.adjacency(G)),adjust_disconnection=TRUE,verbose=FALSE)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
dist=test_bootstrap_shiny_ST(N=20,list(power=2.0),opts=1,B)
dist=test_bootstrap_shiny_ST(N=20,list(power=2.0),opts=1,B=10)
dist
args=list(p=2.0);A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
opts
args=list(p=2.0);opts=0;A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
args=list(p=0.1);opts=0;A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
A2
stree<-get_number_spanning_trees(A)
stree
stree2<-get_number_spanning_trees(A2)
stree2
stree+stree2
abs(stree-stree2)
abs(stree-stree2)/abs(stree+stree2)
abs(stree-stree2)
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
dist=test_bootstrap_shiny_ST(N=20,list(p=0.1),opts=0,B=10)
dist
dist=test_bootstrap_shiny_ST(N=20,list(power=1.4),opts=1,B=10)
dist
opts=1
agrs=list(power=1.4)
args=list(power=1.4);A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
A2
stree<-get_number_spanning_trees(A)
stree2<-get_number_spanning_trees(A2)
stree
stree2
graph=graph_from_adjacency_matrix(A2, mode = "undirected")
plot(graph)
log(stree2)
log(abs(stree2))
exp(stree2)
abs(stree-stree1)/abs(stree+stree2)
abs(stree-stree2)/abs(stree+stree2)
abs(stree-stree2)/abs(0.5*(stree+stree2))
normalize_ST=TRUE
ifelse(normalize_ST,abs(stree-stree2)/abs(0.5*(stree+stree2)),abs(stree-stree2))
normalize_ST=FALSE
ifelse(normalize_ST,abs(stree-stree2)/abs(0.5*(stree+stree2)),abs(stree-stree2))
source('~/Dropbox/TrackingNetworkChanges/tests_synthetic_data/tests_bootstrap.R', echo=TRUE)
dist=test_bootstrap_shiny_ST(N,args,opts=1,B,normalize_ST=FALSE)
B=10
test_bootstrap_shiny_ST<-function(N,args,opts=1,B,normalize_ST=FALSE)
dist=test_bootstrap_shiny_ST(N,args,opts=1,B,normalize_ST=FALSE)
dist
dist=test_bootstrap_shiny_ST(N,args,opts=1,B,normalize_ST=TRUE)
dist
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
names=cbind(names,paste("alpha_graph=",powerlist[it]))
}
boxplot(t(dist),names=names,main="Spanning distances for a Power Law graph (a=1.4) on 100 nodes")
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
names=cbind(names,paste("alpha_graph=",powerlist[it]))
}
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
names=cbind(names,paste("alpha_graph=",powerlist[it]))
}
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
print(it);args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
names=cbind(names,paste("alpha_graph=",powerlist[it]))
}
powerlist[it]
test_bootstrap_shiny_ST(N,args,opts=1,B=100)
for(b in 1:B){
print(b)
if (opts==0){
p=args$p
A<-generate_random_adjacency(N,p, TRUE)
A2<-generate_random_adjacency(N,p, TRUE)
}
else{
A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
}
stree<-get_number_spanning_trees(A)
stree2<-get_number_spanning_trees(A2)
dist[6,b]=ifelse(normalize_ST,abs(stree-stree2)/abs(0.5*(stree+stree2)),abs(stree-stree2))
})
for(b in 1:B){
print(b)
if (opts==0){
p=args$p
A<-generate_random_adjacency(N,p, TRUE)
A2<-generate_random_adjacency(N,p, TRUE)
}
else{
A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
}
stree<-get_number_spanning_trees(A)
stree2<-get_number_spanning_trees(A2)
dist[6,b]=ifelse(normalize_ST,abs(stree-stree2)/abs(0.5*(stree+stree2)),abs(stree-stree2))
}
for(b in 1:100){
print(b)
if (opts==0){
p=args$p
A<-generate_random_adjacency(N,p, TRUE)
A2<-generate_random_adjacency(N,p, TRUE)
}
else{
A<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A<-as.matrix(get.adjacency(A))
A2<-generate_realistic_adjacency(N,args_l=args,opts=opts, verbose=FALSE)
A2<-as.matrix(get.adjacency(A2))
}
stree<-get_number_spanning_trees(A)
stree2<-get_number_spanning_trees(A2)
dist[6,b]=ifelse(normalize_ST,abs(stree-stree2)/abs(0.5*(stree+stree2)),abs(stree-stree2))
}
graph=graph_from_adjacency_matrix(A, mode = "undirected")
plot(graph)
graph2=graph_from_adjacency_matrix(A2, mode = "undirected")
plot(graph2)
get_number_spanning_trees(A)
get_number_spanning_trees(A2)
A0=A
A=A2
N=nrow(A)
#B_ref<-(-1.0)*as.matrix(A)
D<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
if (length(D==0)>0 & verbose ) print(paste("isolated node(s): ",which(D==0)))
D
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
get_number_spanning_trees(A2)
N=nrow(A)
#B_ref<-(-1.0)*as.matrix(A)
D<-apply(A,1,sum)  ### degree (diagonal should be the degree of each node)
if (sum(D==0)>0 & verbose ) print(paste("isolated node(s): ",which(D==0)))
D
if (sum(which(D==0))>0 && N>2 && adjust_disconnection==TRUE){  ## adjust the disconnection
index=which(D==0)
index_connected<-setdiff(1:N,index)
A<-A[index_connected,index_connected]
return(get_number_spanning_trees(A,adjust_disconnection=TRUE))
}
#### We now have to take care of isolated blocks
else{
if(N<3){
nb=ifelse(sum(diag(D))==0,0,1) ## 2 nodes= 1 ST
}
else{
if (length(which(diag(B_ref)==0))>0 &&  adjust_disconnection==FALSE){  ### just in case we do not want to take care of the issue
nb=sum(abs(A))/(N*(N-1)) ## outputs the sparsity instead
}
else{
D<-apply(A,1,sum)
D=diag(D)
lambda=eigen(D-A,only.values = T) ## eigenvalues of the Laplacian
## check the number of disconnect blocks
nb_blocks=sum(lambda$values<10^(-14)) ###numerical error
if (nb_blocks==1){
### Only one connected component. Straightforward.
ll=lambda$values[which(lambda$values>10^(-14))]
nb=-log(N)+sum(log(ll))
}
else{
### Several connected Components. Add up the number of ST in each component.
graph=graph_from_adjacency_matrix(A, mode = "undirected")
index_cliques=igraph::components(graph)
for (l in 1:index_cliques$no){
selection=which(index_cliques$membership==l)
nb<-nb+get_number_spanning_trees(A[selection,selection])
}
}
}
}
if(N<3){
nb=ifelse(sum(diag(D))==0,0,1) ## 2 nodes= 1 ST
}
if(N<3){
print("yay");nb=ifelse(sum(diag(D))==0,0,1) ## 2 nodes= 1 ST
}
if (length(which(diag(B_ref)==0))>0 &&  adjust_disconnection==FALSE){  ### just in case we do not want to take care of the issue
print("yay"); nb=sum(abs(A))/(N*(N-1)) ## outputs the sparsity instead
}
D<-apply(A,1,sum)
D=diag(D)
lambda=eigen(D-A,only.values = T) ## eigenvalues of the Laplacian
## check the number of disconnect blocks
nb_blocks=sum(lambda$values<10^(-14)) ###numerical error
lambda=eigen(D-A,only.values = T)
lambda
nb_blocks=sum(lambda$values<10^(-14))
nb_blocks
nb_blocks=sum(lambda$values<10^(-12)) ###numerical error
source('~/Dropbox/TrackingNetworkChanges/distances/spanning_trees.R', echo=TRUE)
get_number_spanning_trees(A2)
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
names=cbind(names,paste("alpha_graph=",powerlist[it]))
}
boxplot(t(dist),names=names,main="Spanning distances for a Power Law graph (a=1.4) on 100 nodes")
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
names=cbind(names,paste("alpha_graph=",powerlist[it]))
}
boxplot(t(dist),names=names,main="Spanning distances for a Power Law graph (a=1.4) on 100 nodes")
dist=test_bootstrap_shiny_HIM(N,args,opts=1,B)
View(dist)
distHIM=matrix(0,3,length(power_list),100)
View(distHIM)
N=100
powerlist=c(0.2,0.4,0.6,0.8,1.0,1.4,1.7,3,3.5)
dist=matrix(0,length(power_list),100)
distH=matrix(0,length(power_list),100)
distIM=matrix(0,length(power_list),100)
distHIM=matrix(0,length(power_list),100)
names=c()
for (it in 1:length(powerlist)){
args=list(power=powerlist[it])
dist[it,]=test_bootstrap_shiny_ST(N,args,opts=1,B=100)
dist_temp=test_bootstrap_shiny_HIM(N,args,opts=1,B=100)
distH[it,]=dist_temp[1,]
distIM[it,]=dist_temp[2,]
distHIM[it,]=dist_temp[3,]
names=cbind(names,paste("alpha=",powerlist[it]))
}
x=2
y=3
x+y
x
q()
