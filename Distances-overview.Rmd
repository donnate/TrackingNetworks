---
title: "Using the different distances"
author: "Claire Donnat"
date: "1/19/2018"
output:
  pdf_document: default
  html_document: default
---


This notebook just provides a quick overview of the different distances that have been compared.


##  Graph generation

Graphs can be generated by calling the function __generate_realistic_adjacency__, which can generate 4 types of graph (through the igraph library) by changing the **opts** parameter:

+ __opts=0: ER-random graph__, with parameters $N$ (number of nodes), and $p$ (probability of connection).
+ __opts=1: Barabasi and Albert-random graph__ with parameters $N$ (number of nodes), and $power$.
+ __opts=2: Island graph__: clique model in which every island is an ER graph, and islands are connected through a pre-specified number of edges. The parameters  for this model are $islands.n$ (number of islands), $islands.size$ (list providing the number of nodes per island),  $islands.pin$: list providing the intra-island connectivity (probability of an edge between two nodes in the same island), and $n.inter$: number of edges between each island and the rest (see igraph documentation for additional details)
+
+ __opts=3: Dot-Product-random graph__ with parameters $K$ (the dimension of the hidden embedding vector: see igraph documentation for additional details)
+ __opts=4: SBM-random graph__ with parameters $block.sizes$ (list providing the size of each block) and pm (connection probability matrix). This is in spirit similar to the island graph, but provides in general denser graphs.



```{r setup,echo=FALSE}
knitr::opts_knit$set(root.dir = '~/Dropbox/TrackingNetworkChanges')
print(paste("Working directory set to",getwd()))
source("main.R")
print("All functions loaded.")
```


Here are a few examples:

+ ER graph (opts=0):
```{r, echo=TRUE,fig.width=10, fig.height=4}
N=50
Adj=generate_realistic_adjacency(N,opts=0,args=list(),verbose=TRUE,p=0.16)
```
+PA graph
```{r,PA,fig.width=10, fig.height=4}
G=generate_realistic_adjacency(N,opts=2,args=list(),verbose=TRUE,power=2.4)
```
+SBM graph
```{r,SBM,fig.width=10, fig.height=4}
G=generate_realistic_adjacency(N,opts=4,args=list(),verbose=TRUE,pm=cbind( c(0.4,0.1, 0.001), c(.1,0.2, .01),c(.001,0.01, .5)))
```

## Using the different distances

Loading all the functions provides a wrapper which (hopefully), makes it easier to select and compute distances. Options include:

+ the Hamming, IM and Mikhailov distances, computed by neettools.

```{r,HIM}

#### Generate first matrix
N=70
args_l<-list(p=0.1,power=1.7,islands.n=3,islands.size=9,islands.pin=0.3,n.inter=3,K=6,block.sizes=c(10,10,10),pm=cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5)))
Ag<-generate_realistic_adjacency(N,opts=1, args_l=args_l,verbose=TRUE)
A<-as(get.adjacency(Ag),"matrix")

#### Generate evolution
prop=0.3
p=0.4
A_new<-random_alteration_adjacency(A,prop,p)
dist=netdist(A, A_new,d = "HIM")
print(dist)
```


+ Spanning Tree distances

```{r,ST}

#### Generate first matrix
N=70
args_l<-list(p=0.1,power=1.7,islands.n=3,islands.size=9,islands.pin=0.3,n.inter=3,K=6,block.sizes=c(10,10,10),pm=cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5)))
Ag<-generate_realistic_adjacency(N,opts=4, args_l=args_l,verbose=TRUE)
A<-as(get.adjacency(Ag),"matrix")

#### Generate evolution
prop=0.3
p=0.4
A_new<-random_alteration_adjacency(A,prop,p)
sp_Anew=get_number_spanning_trees(A_new)
sp_A=get_number_spanning_trees(A)
#print(c(sp_A,sp_Anew))
dist=abs(log(max(sp_A,1))-log(max(sp_Anew,1)))
print(dist)
```


+ Polynomial Distances, which require the specification of the downweighting factor $\alpha$ and the order of the polynomial:
```{r,Poly}

#### Generate first matrix
N=70
args_l<-list(p=0.1,power=1.7,islands.n=3,islands.size=9,islands.pin=0.3,n.inter=3,K=6,block.sizes=c(10,10,10),pm=cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5)))
Ag<-generate_realistic_adjacency(N,opts=1, args_l=args_l,verbose=TRUE)
A<-as(get.adjacency(Ag),"matrix")

#### Generate evolution
prop=0.3
p=0.4
dist=poly_distance(A, A_new,order_max=3,alpha=0.9)
print(dist)
```

+ Eigenvalue-based distances, which require the specification of the filter:
```{r,Eigenvalue}

#### Generate first matrix
N=70
args_l<-list(p=0.1,power=1.7,islands.n=3,islands.size=9,islands.pin=0.3,n.inter=3,K=6,block.sizes=c(10,10,10),pm=cbind( c(.4,0.1, .001), c(.1,0.2, .01),c(.001,0.01, .5)))
Ag<-generate_realistic_adjacency(N,opts=1, args_l=args_l,verbose=TRUE)
A<-as(get.adjacency(Ag),"matrix")

#### Generate evolution
prop=0.3
p=0.4
dist=eigen_distance(A, A_new,function(x){ifelse(x<2,x,0)})
print(dist)
```

